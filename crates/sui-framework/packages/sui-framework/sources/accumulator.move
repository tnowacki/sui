// Accumulator but with lots of private generics
module sui::accumulator;

use sui::config::{Self, Config};

/*
Open questions:
1. What is the storage/data layout? Do we need a Move representation? e.g.
   public struct Accumulator<phantom T> { overflow: u256, balance: u256, curse: u256 } has store;
2. Limits on add/withdraw per transaction?
3. Fees on add? We can't charge storage fees.
4. Object versioning? When are they updated?
5. Do we want `Seize` to just take the full amount "locked"?
6. Do we want separate flags for locking and seizing?
7. Event for locking/seizing?
8. Object `Withdrawal` is a pickle. How do we "authenticate" them as transaction inputs? In other,
   words, we have no way of stopping someone from making a `Withdrawal` for an object and not using
   it. This is a problem since `Withdrawal` is needed for transaction scheduling. This is unlike
   `Receiving`, where we could ignore the argument until it was used.
*/


// These should maybe maybe charge a fee for storage attacks since we cannot charge for storage
// directly like for dynamic field creation
// They do nothing if the value is zero
// Two custom verifier rules
// - `T internal`, that is this invoked from the module that defines `T`
// - `T` is a type with a single `u[8,16,32,64,128,u256]` field.
//   - Could also be a Struct of a single struct that satisfies the property recursively. This
//     allows for layering which may be helpful for building on top of other modules/types.
public fun add</* internal */ T: store>(value: T, recipient: address, ctx: &mut TxContext) {
    assert!(is_registered<T>(ctx));
    add_impl(value, recipient)
}

// We bypass the registry for coins/balance for migration purposes. New coins will be registered
// if they have a `AdminCap`
// We probably want to limit the size of Set<(TypeTag<T>, Address)> in a transaction,
// for memory impact per checkpoint
public(package) native fun add_impl<T: store>(value: T, recipient: address);

// Generated by `CallArg::Withdrawal { location: address, type: TypeInput, limit: Option<u256> }`
// We can check at signing that limit <= max_value<T>() (where max_value<T>() is a function that
// checks the the size of the type of the single integer field in `T`).
// To improve performance, consensus can leverage the limits to run transactions in parallel. But
// it is not part of the core "spec". In other words the following happens:
// - If it is a fast-path object, the limit must be specified.
// - Otherwise, if the limit is specified, it is checked against all other `Withdrawals` with
//   specified limits for the same `location` in the checkpoint.
// - If the limit is not specified, they must be run sequentially for the same `location`.
public struct Withdrawal<phantom T: store> has drop {
    location: address,
    // at signing we check this isn't too big for `T`
    // And for fast-path objects this must be `Some`
    limit: Option<u256>,
}

// Same custom verifier rules as `add`
public fun withdraw_from_sender</* internal */ T: store>(
    withdrawal: &mut Withdrawal<T>,
    value: u256,
    ctx: &mut TxContext,
): T {
    assert!(withdrawal.location == ctx.sender());
    withdraw(withdrawal, value)
}

// Same custom verifier rules as `add`
public fun withdraw_from_object</* internal */ T: store>(
    withdrawal: &mut Withdrawal<T>,
    value: u256,
    obj: &mut UID,
): T {
    assert!(withdrawal.location == obj.to_address());
    withdraw(withdrawal, value)
}

// used for both `withdraw_from_sender` and `seize`
fun withdraw<T: store>(withdrawal: &mut Withdrawal<T>, value: u256): T {
    let location = withdrawal.location;
    withdrawal.limit.do_mut!(|remaining| {
        let r = *remaining;
        assert!(r >= value);
        *remaining = r - value;
    });
    withdraw_impl(location, value)
}

// aborts if the value is greater than the amount in the withdrawal
// Do we need to charge a small fee since we cannot charge storage fees?
// We should limit withdraws to `u*::max` for a `location`
// in a given transaction for the given `u*` in `T`
native fun withdraw_impl<T>(location: address, value: u256): T;

public use fun withdrawal_location as Withdrawal.location;

public fun withdrawal_location<T: store>(withdrawal: &Withdrawal<T>): address {
    withdrawal.location
}

// ID can be well known or just set later
const REGISTRY: address = @0xB0FF0;

public struct RegistryCap() has drop;
public struct TypeKey<phantom T>() has copy, drop, store;

// same verifier rules as `add`
// Before using `add` a type must be registered. This prevents a `AdminCap` from being created
// after the fact.
// Once registered, the type cannot be unregistered.
public fun register_accumulator</* internal */ T: store>(
    registry: &mut Config<RegistryCap>,
    ctx: &mut TxContext,
) {
    assert!(!is_registered<T>(ctx));
    // If the type is not yet registered, we initialize it with `AdminCapFlags(0)`
    // If it a `AdminCap` is created, the value will already be present with possible flags set.
    registry.entry!(&mut RegistryCap(), TypeKey<T>(), |_, _, _| AdminCapFlags(0), ctx);
}

public fun is_registered<T: store>(ctx: &TxContext): bool {
    config::read_setting<_, bool>(object::id_from_address(REGISTRY), TypeKey<T>(), ctx).is_some()
}

public(package) fun set_use_balance_accounts(
    registry: &mut Config<RegistryCap>,
    addr: address,
    use_balance_accounts: bool,
    ctx: &mut TxContext,
) {
   transfer::set_use_balance_accounts(registry, &mut RegistryCap(), addr, use_balance_accounts, ctx)
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Freezing and Seizing

// In some cases, an admin might need to be able to freeze and seize assets. Freezing is simple
// enough in that you can use the DenyList or build your own deny list like object/pattern in your
// module.
// However, we want to make sure that the system is aware of withdrawals not bound to the Sui
// account or object UID. For these cases, we can create a capability `AdminCap<T>` that the system
// knows about when scheduling transactions that have `Withdrawal<T>`s for that same `T`.
// I am assuming that we cannot support `store` on `AdminCap`, but if we could that would be great!
// It might be in the case of it having `store` we would have to do some funky thing when we see
// a `Withdrawal` where the `location` is not the sender.
public struct AdminCap<phantom T> has key, store {
    id: UID,
    flags: AdminCapFlags,
}

public struct AdminCapFlags(u64) has copy, drop, store;

const ALLOWS_LOCKING: u64 = 0x1;
const ALLOWS_SEIZING: u64 = 0x2;

// Generated by `CallArg::Seize { location: address, type: TypeInput, limit: Option<u256> }`
// We can check at signing that limit <= max_value<T>() AND we check that the amount being seized
// is greater than or equal to the amount locked.
// To improve performance, consensus can leverage the limits to run transactions in parallel. But
// it is not part of the core "spec"
public struct Seize<phantom T: store> has drop {
    location: address,
    amount: u256, // at signing we check this isn't too big for `T`. I do not think we need
                  // an option here since this API feels much more intentional ahead of time. That
                  // is the admin has already specified the amount when they called `lock`

}

// We use the registry to allow for creating of seize caps. Once a seize cap is created, the type
// is registered starting next epoch. At which time, `add` can be called.
// Note also, we would likely do the same checks on `T` as we do for `add` and `withdraw`, to
// prevent creating bogus seize caps.
public fun create_admin_cap</* internal */ T: store>(
    registry: &mut Config<RegistryCap>,
    allow_locking: bool,
    allow_seizing: bool,
    ctx: &mut TxContext,
): AdminCap<T> {
    assert!(!is_registered<T>(ctx));
    // We need locking to allow seizing
    // allow_seizing ==> allow_locking
    assert!(!allow_seizing || allow_locking);
    // If the type is not yet registered, we initialize it with `WITH_admin_cap`
    // If it is already registered, we update it to `WITH_admin_cap`
    let flags;
    registry.update!(
        &mut RegistryCap(),
        TypeKey<T>(),
        |_, _, _| AdminCapFlags(0),
        |old_value, flags_mut| {
            assert!(old_value.is_none());
            if (allow_locking) flags_mut.0 = flags_mut.0 | ALLOWS_LOCKING;
            if (allow_seizing) flags_mut.0 = flags_mut.0 | ALLOWS_SEIZING;
            flags = *flags_mut;
        },
        ctx,
    );
    AdminCap { id: object::new(ctx), flags }
}

// Same custom verifier rules as `add`
public fun lock</* internal */T: store>(
    cap: &AdminCap<T>, // since it is internal, we don't _really_ need it to be &mut. I think
    location: address,
    value: u256,
) {
    assert!(cap.flags.allows_locking());
    // should we emit an event here?
    lock_impl<T>(location, value)
}

// Same custom verifier rules as `add`
public fun seize</* internal */T: store>(
    cap: &AdminCap<T>, // since it is internal, we don't _really_ need it to be &mut. I think
    seized: &mut Seize<T>,
    value: u256,
): T {
    assert!(cap.flags.allows_seizing());
    let r = seized.amount;
    assert!(r >= value);
    seized.amount = r - value;
    // should we emit an event here?
    withdraw_impl(seized.location, value)
}

public use fun flags_allows_locking as AdminCapFlags.allows_locking;
fun flags_allows_locking(config: AdminCapFlags): bool {
    config.0 & ALLOWS_LOCKING != 0
}

public use fun flags_allows_seizing as AdminCapFlags.allows_seizing;
fun flags_allows_seizing(config: AdminCapFlags): bool {
    config.0 & ALLOWS_SEIZING != 0
}

native fun lock_impl<T>(location: address, value: u256);

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Balance arg

// We can add a `CallArg::Balance` that is `CallArg::Withdrawal` + `balance::withdraw_from_sender`
// This would be slightly more ergonomic as a transition

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Force using accumulator

// We could reflect on `T` when calling `transfer::transfer` and if it is a Coin<T> we could
// switch to using `balance::send`. We could make this opt in per address via a `Config` or similar
// gating mechanism. I like this choice being on the side of the receiver/recipient.
