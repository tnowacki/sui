// Accumulator but with lots of private generics
module sui::accumulator;

use sui::config::{Self, Config};

/*
Open questions:
1. What is the storage/data layout? Do we need a Move representation? e.g.
   public struct Accumulator<phantom T>(u256) has store;
2. Limits on add/withdraw per transaction?
3. Object versioning? When are they updated?
4. Do we expose a "get_value(): u128" function alongside `withdraw*` functions?
5. Fees on add? We can't charge storage fees.
*/


// These should maybe maybe charge a fee for storage attacks since we cannot charge for storage
// directly like for dynamic field creation
// They do nothing if the value is zero
// Two custom verifier rules
// - `T internal`, that is this invoked from the module that defines `T`
// - `T` is a type with a single `u[8,16,32,64,128]` field. `u256` is not supported.
//   - Could also be a Struct of a single struct that satisfies the property recursively. This
//     allows for layering which may be helpful for building on top of other modules/types.
public fun add</* internal */ T: store>(value: T, recipient: address, ctx: &mut TxContext) {
    assert!(is_registered<T>(ctx));
    add_impl(value, recipient)
}

// We bypass the registry for coins/balance for migration purposes. New coins will be registered
// if they have a `SeizeCap`
// We probably want to limit the size of Set<(TypeTag<T>, Address)> in a transaction,
// for memory impact per checkpoint
public(package) native fun add_impl<T: store>(value: T, recipient: address);

// Generated by `CallArg::Withdrawal { location: address, type: TypeInput, limit: Option<u128> }`
// We can check at signing that limit <= max_value<T>() (where max_value<T>() is a function that
// checks the the size of the type of the single integer field in `T`).
// To improve performance, consensus can leverage the limits to run transactions in parallel. But
// it is not part of the core "spec"
public struct Withdrawal<phantom T: store> has drop {
    location: address,
    limit: Option<u128>, // at signing we check this isn't too big for `T`
}

// Same custom verifier rules as `add`
public fun withdraw_from_sender</* internal */ T: store>(
    withdrawal: &mut Withdrawal<T>,
    value: u128,
    ctx: &mut TxContext,
): T {
    // This assert should be unnecessary. We can check at signing that the withdrawal is valid.
    assert!(withdrawal.location == ctx.sender());
    withdraw(withdrawal, value)
}

// Same custom verifier rules as `add`
public fun withdraw_from_object</* internal */ T: store>(obj: &mut UID, value: u128): T {
    withdraw_impl(obj.to_address(), value)
}

// used for both `withdraw_from_sender` and `seize`
fun withdraw<T: store>(withdrawal: &mut Withdrawal<T>, value: u128): T {
    let location = withdrawal.location;
    withdrawal.limit.do_mut!(|remaining| {
        let r = *remaining;
        assert!(r >= value);
        *remaining = r - value;
    });
    withdraw_impl(location, value)
}

// aborts if the value is greater than the amount in the withdrawal
// Do we need to charge a small fee since we cannot charge storage fees?
// We should limit withdraws to `u*::max` for a `location`
// in a given transaction for the given `u*` in `T`
native fun withdraw_impl<T>(location: address, value: u128): T;

public use fun withdrawal_location as Withdrawal.location;

public fun withdrawal_location<T: store>(withdrawal: &Withdrawal<T>): address {
    withdrawal.location
}

// ID can be well known or just set later
const REGISTRY: address = @0xB0FF0;

const WITH_SEIZE_CAP: bool = true;
const WITHOUT_SEIZE_CAP: bool = false;

public struct RegistryCap() has drop;
public struct TypeKey<phantom T>() has copy, drop, store;

// same verifier rules as `add`
// Before using `add` a type must be registered. This prevents a `SeizeCap` from being created
// after the fact.
// Once registered, the type cannot be unregistered.
public fun register_accumulator</* internal */ T: store>(
    registry: &mut Config<RegistryCap>,
    ctx: &mut TxContext,
) {
    assert!(!is_registered<T>(ctx));
    // If the type is not yet registered, we initialize it with `WITHOUT_SEIZE_CAP`
    // If it a `SeizeCap` is created, the value will already be present with `WITH_SEIZE_CAP`
    registry.entry!(&mut RegistryCap(), TypeKey<T>(), |_, _, _| WITHOUT_SEIZE_CAP, ctx);
}

public fun is_registered<T: store>(ctx: &TxContext): bool {
    config::read_setting<_, bool>(object::id_from_address(REGISTRY), TypeKey<T>(), ctx).is_some()
}

public(package) fun set_use_balance_accounts(
    registry: &mut Config<RegistryCap>,
    addr: address,
    use_balance_accounts: bool,
    ctx: &mut TxContext,
) {
   transfer::set_use_balance_accounts(registry, &mut RegistryCap(), addr, use_balance_accounts, ctx)
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Seizing AKA Clawback

// In some cases, an admin might need to be able to freeze and seize assets. Freezing is simple
// enough in that you can use the DenyList or build your own deny list like object/pattern in your
// module.
// However, we want to make sure that the system is aware of withdrawals not bound to the Sui
// account or object UID. For these cases, we can create a capability `SeizeCap<T>` that the system
// knows about when scheduling transactions that have `Withdrawal<T>`s for that same `T`.
// I am assuming that we cannot support `store` on `SeizeCap`, but if we could that would be great!
// It might be in the case of it having `store` we would have to do some funky thing when we see
// a `Withdrawal` where the `location` is not the sender.
public struct SeizeCap<phantom T> has key {
    id: UID,
}

// We use the registry to allow for creating of seize caps. Once a seize cap is created, the type
// is registered starting next epoch. At which time, `add` can be called.
// Note also, we would likely do the same checks on `T` as we do for `add` and `withdraw`, to
// prevent creating bogus seize caps.
public fun create_seize_cap</* internal */ T: store>(
    registry: &mut Config<RegistryCap>,
    ctx: &mut TxContext,
): SeizeCap<T> {
    assert!(!is_registered<T>(ctx));
    // If the type is not yet registered, we initialize it with `WITH_SEIZE_CAP`
    // If it is already registered, we update it to `WITH_SEIZE_CAP`
    registry.update!(
        &mut RegistryCap(),
        TypeKey<T>(),
        |_, _, _| WITH_SEIZE_CAP,
        |old_value, value_mut| {
            assert!(old_value.is_none());
            *value_mut = WITH_SEIZE_CAP;
        },
        ctx,
    );
    SeizeCap { id: object::new(ctx) }
}

public fun seize</* internal */T: store>(
    _cap: &SeizeCap<T>, // since it is internal, we don't _really_ need it to be &mut. I think
    withdrawal: &mut Withdrawal<T>,
    value: u128,
): T {
    // should we emit an event here?
    withdraw(withdrawal, value)
}

public use fun seize_cap_transfer as SeizeCap.transfer;

public fun seize_cap_transfer<T>(cap: SeizeCap<T>, recipient: address) {
    transfer::transfer(cap, recipient)
}

public use fun seize_cap_share as SeizeCap.share;

#[allow(lint(share_owned))]
public fun seize_cap_share<T>(cap: SeizeCap<T>) {
    transfer::share_object(cap)
}

public use fun seize_cap_freeze as SeizeCap.freeze;

public fun seize_cap_freeze<T>(cap: SeizeCap<T>) {
    transfer::freeze_object(cap)
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Balance arg

// We can add a `CallArg::Balance` that is `CallArg::Withdrawal` + `balance::withdraw_from_sender`
// This would be slightly more ergonomic as a transition

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Force using accumulator

// We could reflect on `T` when calling `transfer::transfer` and if it is a Coin<T> we could
// switch to using `balance::send`. We could make this opt in per address via a `Config` or similar
// gating mechanism. I like this choice being on the side of the receiver/recipient.
