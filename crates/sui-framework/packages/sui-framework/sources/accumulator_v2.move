// Accumulator but with lots of private generics
module sui::accumulator;

// These should maybe maybe charge a fee for storage attacks since we cannot charge for storage
// directly like for dynamic field creation
// They do nothing if the value is zero
// Two custom verifier rules
// - `T internal`, that is this invoked from the module that defines `T`
// - `T` is a type with a single `u[8,16,32,64,128]` field. `u256` is not supported.
//   - Could also be a Struct of a single struct that satisfies the property recursively. This
//     allows for layering which may be helpful for building on top of other modules/types.
public native fun add<T: store>(value: T, recipient: address);

// Generated by `CallArg::Withdrawal { location: address, type: TypeInput, limit: Option<u128> }`
// We can check at signing that limit <= max_value<T>() (where max_value<T>() is a function that
// checks the the size of the type of the single integer field in `T`).
// To improve performance, consensus can leverage the limits to run transactions in parallel. But
// it is not part of the core "spec"
public struct Withdrawal<phantom T: store> has drop {
    location: address,
    limit: Option<u128>, // at signing we check this isn't too big for `T`
}

// Same custom verifier rules as `add`
public fun withdraw_from_sender<T: store>(
    withdrawal: &mut Withdrawal<T>,
    value: u128,
    ctx: &mut TxContext,
): T {
    // This assert should be unnecessary. We can check at signing that the withdrawal is valid.
    assert!(withdrawal.location == ctx.sender());
    withdraw(withdrawal, value)
}

// Same custom verifier rules as `add`
public fun withdraw_from_object<T: store>(obj: &mut UID, value: u128): T {
    withdraw_impl(obj.to_address(), value)
}

// used for both `withdraw_from_sender` and `seize`
fun withdraw<T: store>(withdrawal: &mut Withdrawal<T>, value: u128): T {
    let location = withdrawal.location;
    withdrawal.limit.do_mut!(|remaining| {
        let r = *remaining;
        assert!(r >= value);
        *remaining = r - value;
    });
    withdraw_impl(location, value)
}

// aborts if the value is greater than the amount in the withdrawal
// Do we need to charge a small fee since we cannot charge storage fees?
native fun withdraw_impl<T>(location: address, value: u128): T;

public use fun withdrawal_location as Withdrawal.location;

public fun withdrawal_location<T: store>(withdrawal: &Withdrawal<T>): address {
    withdrawal.location
}
////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Seizing AKA Clawback

// In some cases, an admin might need to be able to freeze and seize assets. Freezing is simple
// enough in that you can use the DenyList or build your own deny list like object/pattern in your
// module.
// However, we want to make sure that the system is aware of withdrawals not bound to the Sui
// account or object UID. For these cases, we can create a capability `SeizeCap<T>` that the system
// knows about when scheduling transactions that have `Withdrawal<T>`s for that same `T`.
// I am assuming that we cannot support `store` on `SeizeCap`, but if we could that would be great!
// It might be in the case of it having `store` we would have to do some funky thing when we see
// a `Withdrawal` where the `location` is not the sender.
public struct SeizeCap<phantom T> has key {
    id: UID,
}

// Ideally, this should only be done via a one time witness, since otherwise an upgrade could
// introduce a seize cap for an asset after it was created. But since this is setup with `T`
// we can't really do that. Additionally, if we want things like Balance<X> and Balance<Y> we can't
// rely on a OTW from the module declaring Balance since it would need to create more than one cap.
// In short, I think this should be limited to init, but I am not sure how to enforce that without
// being exploitable.
// Note also, we would likely do the same checks on `T` as we do for `add` and `withdraw`, to
// prevent creating bogus seize caps.
public fun create_seize_cap<T: store>(ctx: &mut TxContext): SeizeCap<T> {
    // emit an event here?
    SeizeCap { id: object::new(ctx) }
}

public fun seize<T: store>(
    _cap: &SeizeCap<T>, // since it is internal, we don't _really_ need it to be &mut. I think
    withdrawal: &mut Withdrawal<T>,
    value: u128,
): T {
    // should we emit an event here?
    withdraw(withdrawal, value)
}

public use fun seize_cap_transfer as SeizeCap.transfer;

public fun seize_cap_transfer<T>(cap: SeizeCap<T>, recipient: address) {
    transfer::transfer(cap, recipient)
}

public use fun seize_cap_share as SeizeCap.share;

#[allow(lint(share_owned))]
public fun seize_cap_share<T>(cap: SeizeCap<T>) {
    transfer::share_object(cap)
}

public use fun seize_cap_freeze as SeizeCap.freeze;

public fun seize_cap_freeze<T>(cap: SeizeCap<T>) {
    transfer::freeze_object(cap)
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Balance arg

// We can add a `CallArg::Balance` that is `CallArg::Withdrawal` + `balance::withdraw_from_sender`
// This would be slightly more ergonomic as a transition

////////////////////////////////////////////////////////////////////////////////////////////////////

// EXTENSION: Force using accumulator

// We could reflect on `T` when calling `transfer::transfer` and if it is a Coin<T> we could
// switch to using `balance::send`. We could make this opt in per address via a `Config` or similar
// gating mechanism. I like this choice being on the side of the receiver/recipient.
