// Accumulator but with lots of private generics
module sui::accumulator;

// These should maybe maybe charge a fee for storage attacks since we cannot charge for storage
// directly like for dynamic field creation
// They do nothing if the value is zero
// Two custom verifier rules
// - `T internal`, that is this invoked from the module that defines `T`
// - `T` is a type with a single `u[8,16,32,64,128]` field. `u256` is not supported.
public native fun add</* internal */T: store>(value: T, recipient: address);

// Generated by `CallArg::Withdrawal { location: address, type: TypeInput, amount: u128 }`
// We can check at signing that amount <= max_value<T>() (where max_value<T>() is a function that
// checks the the size of the type of the single integer field in `T`).
public struct Withdrawal<phantom T: store> has drop {
    location: address,
    amount: Option<u128>, // at signing we check this isn't too big for `T`
}

// Same custom verifier rules as `add`
public fun withdraw_from_sender</* internal */T: store>(
    withdrawal: &mut Withdrawal<T>,
    value: u128,
    ctx: &mut TxContext,
): T {
    assert!(withdrawal.location == ctx.sender());
    withdraw(withdrawal, value)
}

// Same custom verifier rules as `add`
public fun withdraw_from_object</* internal */T: store>(
    obj: &mut UID,
    value: u128,
): T {
    withdraw_impl(obj.to_address(), value)
}

public(package) fun withdraw<T: store>(withdrawal: &mut Withdrawal<T>, value: u128): T {
    let location = withdrawal.location;
    withdrawal.amount.do_mut!(|amount| {
        let a = *amount;
        assert!(a >= value);
        *amount = a - value;
    });
    withdraw_impl(location, value)
}

// aborts if the value is greater than the amount in the withdrawal
native fun withdraw_impl<T>(location: address, value: u128): T;

public use fun withdrawal_location as Withdrawal.location;

public fun withdrawal_location<T: store>(withdrawal: &Withdrawal<T>): address {
    withdrawal.location
}
